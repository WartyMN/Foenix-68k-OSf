<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Foenix A2650 OS/f Library: general.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Foenix A2650 OS/f Library
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('general_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">general.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &quot;a2560k.h&quot;</code><br />
</div>
<p><a href="general_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_coordinate.html">Coordinate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d15a10ba145726c598611b6eb97cf0d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a6d15a10ba145726c598611b6eb97cf0d">General_Round</a> (double the_float)</td></tr>
<tr class="memdesc:a6d15a10ba145726c598611b6eb97cf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a float to the nearest integer value THINK C's and SAS/C's math.h don't include round() from: <a href="https://stackoverflow.com/questions/4572556/concise-way-to-implement-round-in-c">https://stackoverflow.com/questions/4572556/concise-way-to-implement-round-in-c</a>.  <a href="general_8h.html#a6d15a10ba145726c598611b6eb97cf0d">More...</a><br /></td></tr>
<tr class="separator:a6d15a10ba145726c598611b6eb97cf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1db800160346891a591a3525a25ef0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#ad1db800160346891a591a3525a25ef0c">General_StrToLower</a> (char *the_string)</td></tr>
<tr class="memdesc:ad1db800160346891a591a3525a25ef0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string, in place, to lower case This overwrites the string with a lower case version of itself.  <a href="general_8h.html#ad1db800160346891a591a3525a25ef0c">More...</a><br /></td></tr>
<tr class="separator:ad1db800160346891a591a3525a25ef0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382de78a30fe9774549e3cd59aaa482a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a382de78a30fe9774549e3cd59aaa482a">General_ToLower</a> (uint8_t the_char)</td></tr>
<tr class="memdesc:a382de78a30fe9774549e3cd59aaa482a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the case of the passed character from upper to lower (if necessary) Scope is limited to characters A-Z, ascii.  <a href="general_8h.html#a382de78a30fe9774549e3cd59aaa482a">More...</a><br /></td></tr>
<tr class="separator:a382de78a30fe9774549e3cd59aaa482a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9183cacd116dce96a1f812376fa4ab4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#aa9183cacd116dce96a1f812376fa4ab4">General_StrlcpyWithAlloc</a> (const char *src, size_t max_len)</td></tr>
<tr class="memdesc:aa9183cacd116dce96a1f812376fa4ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for a new string and copies up to max_len - 1 characters from the NUL-terminated string src to the new string, NUL-terminating the result This is meant to be a one stop shop for getting a copy of a string.  <a href="general_8h.html#aa9183cacd116dce96a1f812376fa4ab4">More...</a><br /></td></tr>
<tr class="separator:aa9183cacd116dce96a1f812376fa4ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba901b1ba3cdac4a799c0ad80ead431"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a6ba901b1ba3cdac4a799c0ad80ead431">General_Strlcpy</a> (char *dst, const char *src, size_t max_len)</td></tr>
<tr class="memdesc:a6ba901b1ba3cdac4a799c0ad80ead431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies up to max_len - 1 characters from the NUL-terminated string src to dst, NUL-terminating the result.  <a href="general_8h.html#a6ba901b1ba3cdac4a799c0ad80ead431">More...</a><br /></td></tr>
<tr class="separator:a6ba901b1ba3cdac4a799c0ad80ead431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3f30865088d4004569905b7500320b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#adf3f30865088d4004569905b7500320b">General_Strlcat</a> (char *dst, const char *src, size_t max_len)</td></tr>
<tr class="memdesc:adf3f30865088d4004569905b7500320b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies up to max_len - 1 characters from the NUL-terminated string src and appends to the end of dst, NUL-terminating the result.  <a href="general_8h.html#adf3f30865088d4004569905b7500320b">More...</a><br /></td></tr>
<tr class="separator:adf3f30865088d4004569905b7500320b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf976abc85b331ea32e871465fea774"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#aacf976abc85b331ea32e871465fea774">General_Strncmp</a> (const char *string_1, const char *string_2, size_t max_len)</td></tr>
<tr class="memdesc:aacf976abc85b331ea32e871465fea774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a case sensitive comparison of the specified number of characters of the two passed strings Stops processing once max_len has been reached, or when one of the two strings has run out of characters.  <a href="general_8h.html#aacf976abc85b331ea32e871465fea774">More...</a><br /></td></tr>
<tr class="separator:aacf976abc85b331ea32e871465fea774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce61a7026c30f3f0d29f994e4471b61"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a6ce61a7026c30f3f0d29f994e4471b61">General_Strncasecmp</a> (const char *string_1, const char *string_2, size_t max_len)</td></tr>
<tr class="memdesc:a6ce61a7026c30f3f0d29f994e4471b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a case insensitive comparison of the specified number of characters of the two passed strings Stops processing once max_len has been reached, or when one of the two strings has run out of characters.  <a href="general_8h.html#a6ce61a7026c30f3f0d29f994e4471b61">More...</a><br /></td></tr>
<tr class="separator:a6ce61a7026c30f3f0d29f994e4471b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01666e828eb7979c673db0ec1321f32e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a01666e828eb7979c673db0ec1321f32e">General_Strnlen</a> (const char *the_string, size_t max_len)</td></tr>
<tr class="memdesc:a01666e828eb7979c673db0ec1321f32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the length of a fixed-size string Safe(r) strlen function: will stop processing if no terminator found before max_len reached.  <a href="general_8h.html#a01666e828eb7979c673db0ec1321f32e">More...</a><br /></td></tr>
<tr class="separator:a01666e828eb7979c673db0ec1321f32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6823b507adb7b9fdadf44ad29c7ead4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a6823b507adb7b9fdadf44ad29c7ead4f">General_RectWithinRect</a> (<a class="el" href="struct_rectangle.html">Rectangle</a> r1, <a class="el" href="struct_rectangle.html">Rectangle</a> r2)</td></tr>
<tr class="memdesc:a6823b507adb7b9fdadf44ad29c7ead4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if one rectangle is entirely within the bounds of another <a class="el" href="struct_rectangle.html">Rectangle</a>.  <a href="general_8h.html#a6823b507adb7b9fdadf44ad29c7ead4f">More...</a><br /></td></tr>
<tr class="separator:a6823b507adb7b9fdadf44ad29c7ead4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64d19ccaf76bb0c8102f249b5f202fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#af64d19ccaf76bb0c8102f249b5f202fe">General_CopyRect</a> (<a class="el" href="struct_rectangle.html">Rectangle</a> *r1, <a class="el" href="struct_rectangle.html">Rectangle</a> *r2)</td></tr>
<tr class="memdesc:af64d19ccaf76bb0c8102f249b5f202fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy values of one rect to another.  <a href="general_8h.html#af64d19ccaf76bb0c8102f249b5f202fe">More...</a><br /></td></tr>
<tr class="separator:af64d19ccaf76bb0c8102f249b5f202fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4b1ee409d6776186ce7fc8bfd91d28"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a7c4b1ee409d6776186ce7fc8bfd91d28">General_CalculateRectDifference</a> (<a class="el" href="struct_rectangle.html">Rectangle</a> *r1, <a class="el" href="struct_rectangle.html">Rectangle</a> *r2, <a class="el" href="struct_rectangle.html">Rectangle</a> *diff_r1, <a class="el" href="struct_rectangle.html">Rectangle</a> *diff_r2, <a class="el" href="struct_rectangle.html">Rectangle</a> *diff_r3, <a class="el" href="struct_rectangle.html">Rectangle</a> *diff_r4)</td></tr>
<tr class="memdesc:a7c4b1ee409d6776186ce7fc8bfd91d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the difference between 2 rectangles and populate 0, 1, 2, 3, or 4 new rectangles with the difference If Rect 1 is larger than Rect 2, no new rect will be populated If Rect 1 is smaller than Rect 2 in one dimension (axis) only, 1 new rect will be populated If Rect 1 is smaller than Rect 2 in two dimensions (axes), 3 new rect will be populated If Rect 1 is same size as Rect 2 and moved in one dimension (axis) only, 1 new rect will be populated If Rect 1 is same size as Rect 2 and moved in two dimensions (axes), 3 new rect will be populated.  <a href="general_8h.html#a7c4b1ee409d6776186ce7fc8bfd91d28">More...</a><br /></td></tr>
<tr class="separator:a7c4b1ee409d6776186ce7fc8bfd91d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3348567899570f7c7772d33666ee16ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a3348567899570f7c7772d33666ee16ac">General_CalculateRectIntersection</a> (<a class="el" href="struct_rectangle.html">Rectangle</a> *r1, <a class="el" href="struct_rectangle.html">Rectangle</a> *r2, <a class="el" href="struct_rectangle.html">Rectangle</a> *intersect_r)</td></tr>
<tr class="memdesc:a3348567899570f7c7772d33666ee16ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the intersection between 2 rectangles, storing result in the 3rd rect passed.  <a href="general_8h.html#a3348567899570f7c7772d33666ee16ac">More...</a><br /></td></tr>
<tr class="separator:a3348567899570f7c7772d33666ee16ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7c7c706da5a7e741985c84d76fa3f8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#afd7c7c706da5a7e741985c84d76fa3f8">General_NamePart</a> (const char *the_file_path)</td></tr>
<tr class="memdesc:afd7c7c706da5a7e741985c84d76fa3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the first char of the last part of a file path if no path part detected, returns the original string not guaranteed that this is a FILENAME, as if you passed a path to a dir, it would return the DIR name ex: General_NamePart("/hd/yyy/zzz/myfile.txt") would return a pointer to 'myfile.txt'.  <a href="general_8h.html#afd7c7c706da5a7e741985c84d76fa3f8">More...</a><br /></td></tr>
<tr class="separator:afd7c7c706da5a7e741985c84d76fa3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778d91378a30690d6ba90eb5b5c306c7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a778d91378a30690d6ba90eb5b5c306c7">General_PathPart</a> (const char *the_file_path)</td></tr>
<tr class="memdesc:a778d91378a30690d6ba90eb5b5c306c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the end of the next-to-last component of a path.  <a href="general_8h.html#a778d91378a30690d6ba90eb5b5c306c7">More...</a><br /></td></tr>
<tr class="separator:a778d91378a30690d6ba90eb5b5c306c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde981427d1921294f66061a4d7ed11b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#abde981427d1921294f66061a4d7ed11b">General_ExtractFileExtensionFromFilename</a> (const char *the_file_name, char *the_extension)</td></tr>
<tr class="memdesc:abde981427d1921294f66061a4d7ed11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract file extension into the passed char pointer, as new lowercased string pointer, if any found.  <a href="general_8h.html#abde981427d1921294f66061a4d7ed11b">More...</a><br /></td></tr>
<tr class="separator:abde981427d1921294f66061a4d7ed11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ad160ccdbe60b46d6d9a1ba2a105bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a20ad160ccdbe60b46d6d9a1ba2a105bf">General_ExtractCoreFilename</a> (const char *the_file_name, char *the_core_part)</td></tr>
<tr class="memdesc:a20ad160ccdbe60b46d6d9a1ba2a105bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract core part of the file name, not including the extension.  <a href="general_8h.html#a20ad160ccdbe60b46d6d9a1ba2a105bf">More...</a><br /></td></tr>
<tr class="separator:a20ad160ccdbe60b46d6d9a1ba2a105bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b45cc507aab82cacfea2c888ed4feee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#a9b45cc507aab82cacfea2c888ed4feee">General_DelayTicks</a> (int32_t ticks)</td></tr>
<tr class="memdesc:a9b45cc507aab82cacfea2c888ed4feee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the specified number of ticks before returning In multi-tasking ever becomes a thing, this is not a multi-tasking-friendly operation.  <a href="general_8h.html#a9b45cc507aab82cacfea2c888ed4feee">More...</a><br /></td></tr>
<tr class="separator:a9b45cc507aab82cacfea2c888ed4feee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31497a81342c86b3c2491eee833dfce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="general_8h.html#ae31497a81342c86b3c2491eee833dfce">General_DelaySeconds</a> (uint16_t seconds)</td></tr>
<tr class="memdesc:ae31497a81342c86b3c2491eee833dfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the specified number of seconds before returning In multi-tasking ever becomes a thing, this is not a multi-tasking-friendly operation.  <a href="general_8h.html#ae31497a81342c86b3c2491eee833dfce">More...</a><br /></td></tr>
<tr class="separator:ae31497a81342c86b3c2491eee833dfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77b9046edaab2fae8c915a8288ed321"><td class="memItemLeft" align="right" valign="top"><a id="ad77b9046edaab2fae8c915a8288ed321" name="ad77b9046edaab2fae8c915a8288ed321"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>General_ByteSwapLong</b> (uint32_t long_needing_swap)</td></tr>
<tr class="memdesc:ad77b9046edaab2fae8c915a8288ed321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bytes big endian &lt;&gt; little endian, for a long NOTE: for a word, see BSWAP() macro. <br /></td></tr>
<tr class="separator:ad77b9046edaab2fae8c915a8288ed321"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7c4b1ee409d6776186ce7fc8bfd91d28" name="a7c4b1ee409d6776186ce7fc8bfd91d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4b1ee409d6776186ce7fc8bfd91d28">&#9670;&#160;</a></span>General_CalculateRectDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t General_CalculateRectDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_rectangle.html">Rectangle</a> *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_rectangle.html">Rectangle</a> *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_rectangle.html">Rectangle</a> *&#160;</td>
          <td class="paramname"><em>diff_r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_rectangle.html">Rectangle</a> *&#160;</td>
          <td class="paramname"><em>diff_r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_rectangle.html">Rectangle</a> *&#160;</td>
          <td class="paramname"><em>diff_r3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_rectangle.html">Rectangle</a> *&#160;</td>
          <td class="paramname"><em>diff_r4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the difference between 2 rectangles and populate 0, 1, 2, 3, or 4 new rectangles with the difference If Rect 1 is larger than Rect 2, no new rect will be populated If Rect 1 is smaller than Rect 2 in one dimension (axis) only, 1 new rect will be populated If Rect 1 is smaller than Rect 2 in two dimensions (axes), 3 new rect will be populated If Rect 1 is same size as Rect 2 and moved in one dimension (axis) only, 1 new rect will be populated If Rect 1 is same size as Rect 2 and moved in two dimensions (axes), 3 new rect will be populated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>- the lead, or foreground rect. When calculating a damage rect, this would typically be the rect of the window after it is moved/resized. </td></tr>
    <tr><td class="paramname">r2</td><td>- the secondary, or background rect. When calculating a damage rect, this would typically be the rect of the window before it is moved/resized. </td></tr>
    <tr><td class="paramname">diff_r1</td><td>- valid pointer to a rect object that will be populated if there is 1 or 3 difference rects resulting from the operation </td></tr>
    <tr><td class="paramname">diff_r2</td><td>- valid pointer to a rect object that will be populated if there are 2 or more difference rects resulting from the operation </td></tr>
    <tr><td class="paramname">diff_r3</td><td>- valid pointer to a rect object that will be populated if there are 3 or more difference rects resulting from the operation </td></tr>
    <tr><td class="paramname">diff_r4</td><td>- valid pointer to a rect object that will be populated if there are 4 difference rects resulting from the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of new rects that represent the difference between the passed rectangles. This indicates how many, if any, of the diff_rects need to be evaluated. Returns -1 on any error condition. </dd></dl>

</div>
</div>
<a id="a3348567899570f7c7772d33666ee16ac" name="a3348567899570f7c7772d33666ee16ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3348567899570f7c7772d33666ee16ac">&#9670;&#160;</a></span>General_CalculateRectIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool General_CalculateRectIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_rectangle.html">Rectangle</a> *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_rectangle.html">Rectangle</a> *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_rectangle.html">Rectangle</a> *&#160;</td>
          <td class="paramname"><em>intersect_r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the intersection between 2 rectangles, storing result in the 3rd rect passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>- valid pointer to a rect object </td></tr>
    <tr><td class="paramname">r2</td><td>- valid pointer to a rect object </td></tr>
    <tr><td class="paramname">intersect_r</td><td>- valid pointer to a rect object that will contain the intersection rectangle, if any, at end of operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: Returns true if there is an intersecting rectangle between r1 and r2. </dd></dl>

</div>
</div>
<a id="af64d19ccaf76bb0c8102f249b5f202fe" name="af64d19ccaf76bb0c8102f249b5f202fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64d19ccaf76bb0c8102f249b5f202fe">&#9670;&#160;</a></span>General_CopyRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void General_CopyRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_rectangle.html">Rectangle</a> *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_rectangle.html">Rectangle</a> *&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy values of one rect to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>- the rectangle to be overwritten (copied into) </td></tr>
    <tr><td class="paramname">r2</td><td>- the rectangle to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae31497a81342c86b3c2491eee833dfce" name="ae31497a81342c86b3c2491eee833dfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31497a81342c86b3c2491eee833dfce">&#9670;&#160;</a></span>General_DelaySeconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void General_DelaySeconds </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the specified number of seconds before returning In multi-tasking ever becomes a thing, this is not a multi-tasking-friendly operation. </p>
<p ><br  />
 </p>

</div>
</div>
<a id="a9b45cc507aab82cacfea2c888ed4feee" name="a9b45cc507aab82cacfea2c888ed4feee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b45cc507aab82cacfea2c888ed4feee">&#9670;&#160;</a></span>General_DelayTicks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void General_DelayTicks </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ticks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the specified number of ticks before returning In multi-tasking ever becomes a thing, this is not a multi-tasking-friendly operation. </p>
<p ><br  />
 </p>

</div>
</div>
<a id="a20ad160ccdbe60b46d6d9a1ba2a105bf" name="a20ad160ccdbe60b46d6d9a1ba2a105bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ad160ccdbe60b46d6d9a1ba2a105bf">&#9670;&#160;</a></span>General_ExtractCoreFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool General_ExtractCoreFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>the_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>the_core_part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract core part of the file name, not including the extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_file_name</td><td>- the file name to extract an extension from </td></tr>
    <tr><td class="paramname">the_core_part</td><td>- a pre-allocated buffer that will contain the pre-extension part of the file name, if any is detected. Must be large enough to hold the entire file name! No bounds checking is done. If no extension is found, this will contain an empty string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false if no file extension found (because what is "core" part without an extension) </dd></dl>

</div>
</div>
<a id="abde981427d1921294f66061a4d7ed11b" name="abde981427d1921294f66061a4d7ed11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde981427d1921294f66061a4d7ed11b">&#9670;&#160;</a></span>General_ExtractFileExtensionFromFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool General_ExtractFileExtensionFromFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>the_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>the_extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract file extension into the passed char pointer, as new lowercased string pointer, if any found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_file_name</td><td>- the file name to extract an extension from </td></tr>
    <tr><td class="paramname">the_extension</td><td>- a pre-allocated buffer that will contain the extension, if any is detected. Must be large enough to hold the extension! No bounds checking is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false if no file extension found. </dd></dl>

</div>
</div>
<a id="afd7c7c706da5a7e741985c84d76fa3f8" name="afd7c7c706da5a7e741985c84d76fa3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7c7c706da5a7e741985c84d76fa3f8">&#9670;&#160;</a></span>General_NamePart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * General_NamePart </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>the_file_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the first char of the last part of a file path if no path part detected, returns the original string not guaranteed that this is a FILENAME, as if you passed a path to a dir, it would return the DIR name ex: General_NamePart("/hd/yyy/zzz/myfile.txt") would return a pointer to 'myfile.txt'. </p>
<p >ex: General_NamePart("myfile.txt") would return a pointer to 'myfile.txt'. amigaDOS compatibility function (see FilePart) </p>

</div>
</div>
<a id="a778d91378a30690d6ba90eb5b5c306c7" name="a778d91378a30690d6ba90eb5b5c306c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778d91378a30690d6ba90eb5b5c306c7">&#9670;&#160;</a></span>General_PathPart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * General_PathPart </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>the_file_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the end of the next-to-last component of a path. </p>
<p >ex: General_PathPart("/hd/yyy/zzz/myfile.txt") would return a pointer to '/myfile.txt'. ex: General_PathPart("myfile.txt") would return a pointer to 'myfile.txt'. amigaDOS compatibility function (see PathPart) </p>

</div>
</div>
<a id="a6823b507adb7b9fdadf44ad29c7ead4f" name="a6823b507adb7b9fdadf44ad29c7ead4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6823b507adb7b9fdadf44ad29c7ead4f">&#9670;&#160;</a></span>General_RectWithinRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool General_RectWithinRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_rectangle.html">Rectangle</a>&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_rectangle.html">Rectangle</a>&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if one rectangle is entirely within the bounds of another <a class="el" href="struct_rectangle.html">Rectangle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>- the rectangle being tested </td></tr>
    <tr><td class="paramname">r2</td><td>- the rectangle being measured to determine if r1 fits entirely within it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: returns true if r1 is within bounds of r2. <br  />
 </dd></dl>

</div>
</div>
<a id="a6d15a10ba145726c598611b6eb97cf0d" name="a6d15a10ba145726c598611b6eb97cf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d15a10ba145726c598611b6eb97cf0d">&#9670;&#160;</a></span>General_Round()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t General_Round </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>the_float</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round a float to the nearest integer value THINK C's and SAS/C's math.h don't include round() from: <a href="https://stackoverflow.com/questions/4572556/concise-way-to-implement-round-in-c">https://stackoverflow.com/questions/4572556/concise-way-to-implement-round-in-c</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_float</td><td>- a double value to round up/down </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an int with the rounded value </dd></dl>

</div>
</div>
<a id="adf3f30865088d4004569905b7500320b" name="adf3f30865088d4004569905b7500320b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3f30865088d4004569905b7500320b">&#9670;&#160;</a></span>General_Strlcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t General_Strlcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies up to max_len - 1 characters from the NUL-terminated string src and appends to the end of dst, NUL-terminating the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>- The string to copy </td></tr>
    <tr><td class="paramname">dst</td><td>- The string to append to. Calling function is responsible for ensuring this string is allocated, and has at least as much storage as max_len. </td></tr>
    <tr><td class="paramname">max_len</td><td>- The maximum number of bytes to use in the destination string, including the terminator. If this is shorter than the length of src + length of dst + 1, the resulting copy string will be capped at max_len - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the length of the attempted concatenated string: initial length of dst plus the length of src. </dd></dl>

</div>
</div>
<a id="a6ba901b1ba3cdac4a799c0ad80ead431" name="a6ba901b1ba3cdac4a799c0ad80ead431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba901b1ba3cdac4a799c0ad80ead431">&#9670;&#160;</a></span>General_Strlcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t General_Strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies up to max_len - 1 characters from the NUL-terminated string src to dst, NUL-terminating the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>- The string to copy </td></tr>
    <tr><td class="paramname">dst</td><td>- The string to copy into. Calling function is responsible for ensuring this string is allocated, and has at least as much storage as max_len. </td></tr>
    <tr><td class="paramname">max_len</td><td>- The maximum number of bytes to use in the destination string, including the terminator. If this is shorter than the length of the source string + 1, the resulting copy string will be capped at max_len - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the length of the source string, or -1 on any error condition </dd></dl>

</div>
</div>
<a id="aa9183cacd116dce96a1f812376fa4ab4" name="aa9183cacd116dce96a1f812376fa4ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9183cacd116dce96a1f812376fa4ab4">&#9670;&#160;</a></span>General_StrlcpyWithAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * General_StrlcpyWithAlloc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for a new string and copies up to max_len - 1 characters from the NUL-terminated string src to the new string, NUL-terminating the result This is meant to be a one stop shop for getting a copy of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>- The string to copy </td></tr>
    <tr><td class="paramname">max_len</td><td>- The maximum number of bytes to use in the destination string, including the terminator. If this is shorter than the length of the source string + 1, the resulting copy string will be capped at max_len - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the source string to max_len, or NULL on any error condition </dd></dl>

</div>
</div>
<a id="a6ce61a7026c30f3f0d29f994e4471b61" name="a6ce61a7026c30f3f0d29f994e4471b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce61a7026c30f3f0d29f994e4471b61">&#9670;&#160;</a></span>General_Strncasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t General_Strncasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a case insensitive comparison of the specified number of characters of the two passed strings Stops processing once max_len has been reached, or when one of the two strings has run out of characters. </p>
<p >Inspired by code from slashdot and apple open source <a href="https://stackoverflow.com/questions/5820810/case-insensitive-string-comparison-in-c">https://stackoverflow.com/questions/5820810/case-insensitive-string-comparison-in-c</a> <a href="https://opensource.apple.com/source/tcl/tcl-10/tcl/compat/strncasecmp.c.auto.html">https://opensource.apple.com/source/tcl/tcl-10/tcl/compat/strncasecmp.c.auto.html</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_1</td><td>- the first string to compare. </td></tr>
    <tr><td class="paramname">string_2</td><td>- the second string to compare. </td></tr>
    <tr><td class="paramname">max_len</td><td>- the maximum number of characters to compare. Even if both strings are larger than this number, only this many characters will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if the strings are equivalent (at least up to max_len). Returns a negative or positive if the strings are different. </dd></dl>

</div>
</div>
<a id="aacf976abc85b331ea32e871465fea774" name="aacf976abc85b331ea32e871465fea774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf976abc85b331ea32e871465fea774">&#9670;&#160;</a></span>General_Strncmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t General_Strncmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a case sensitive comparison of the specified number of characters of the two passed strings Stops processing once max_len has been reached, or when one of the two strings has run out of characters. </p>
<p ><a href="http://home.snafu.de/kdschem/c.dir/strings.dir/strncmp.c">http://home.snafu.de/kdschem/c.dir/strings.dir/strncmp.c</a> TODO: compare this to other implementations, see which is faster. eg, <a href="https://opensource.apple.com/source/Libc/Libc-167/gen.subproj/i386.subproj/strncmp.c.auto.html">https://opensource.apple.com/source/Libc/Libc-167/gen.subproj/i386.subproj/strncmp.c.auto.html</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_1</td><td>- the first string to compare. </td></tr>
    <tr><td class="paramname">string_2</td><td>- the second string to compare. </td></tr>
    <tr><td class="paramname">max_len</td><td>- the maximum number of characters to compare. Even if both strings are larger than this number, only this many characters will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if the strings are equivalent (at least up to max_len). Returns a negative or positive if the strings are different. </dd></dl>

</div>
</div>
<a id="a01666e828eb7979c673db0ec1321f32e" name="a01666e828eb7979c673db0ec1321f32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01666e828eb7979c673db0ec1321f32e">&#9670;&#160;</a></span>General_Strnlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t General_Strnlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>the_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the length of a fixed-size string Safe(r) strlen function: will stop processing if no terminator found before max_len reached. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns strlen(the_string), if that is less than max_len, or max_len if there is no null terminating ('\0') among the first max_len characters pointed to by the_string. </dd></dl>

</div>
</div>
<a id="ad1db800160346891a591a3525a25ef0c" name="ad1db800160346891a591a3525a25ef0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1db800160346891a591a3525a25ef0c">&#9670;&#160;</a></span>General_StrToLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool General_StrToLower </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>the_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string, in place, to lower case This overwrites the string with a lower case version of itself. </p>
<p >Warning: no length check is in place. Calling function must verify string is well-formed (terminated). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_string</td><td>- the string to convert to lower case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the string was modified by the process. </dd></dl>

</div>
</div>
<a id="a382de78a30fe9774549e3cd59aaa482a" name="a382de78a30fe9774549e3cd59aaa482a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382de78a30fe9774549e3cd59aaa482a">&#9670;&#160;</a></span>General_ToLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t General_ToLower </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>the_char</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the case of the passed character from upper to lower (if necessary) Scope is limited to characters A-Z, ascii. </p>
<p >replacement for tolower() in c library, which doesn't seem to work [in Amiga WB2K] for some reason. </p><dl class="section return"><dt>Returns</dt><dd>a character containing the lowercase version of the passed character. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="general_8h.html">general.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
